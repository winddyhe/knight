# Assetbundle Management

## Resource Packaging
![Improved AssetbundleBrowser](https://github.com/winddyhe/knight/blob/master/Doc/res/images/assetbundlebrowser_improved.png)
* A custom resource tag configuration tool that logically categorizes resources into different types, making it easy to classify resources through configuration.
* During the optimization phase of the project, the benefits of resource categorization will become apparent, as it allows for the separation of resources from different functionalities and modules. This facilitates better control over the granularity of resource packages and reduces dependencies between them.
* One important consideration in resource classification is to properly handle the reuse of resources across different AssetBundles, which can be categorized into independent resource packages.

## Resource Updates
### Update Download Process
* In the resource update process of a Unity game, resource packages will exist in three locations: the StreamingAssets space (resources directly included in the game package), the Server space (resources on the server for hot updates), and the Persistent space (resources downloaded from the server).
* During the resource packaging in the framework, a version file ABVersion.Bin with more information and an MD5 checksum file ABVersion_MD5.Bin are generated for the AssetBundle package. The ABVersion.Bin file contains size and version information for the resource packages, in addition to what is generated by Unity.
* Using the above MD5 checksum and version information, it is easy to determine which resource packages need to be updated in the Persistent space.
* The API used for downloading resources is Unity's UnityWebRequest.
* The resource update process is as follows:
	1. Load the ABVersion_MD5.Bin file from the Persistent space.
	2. Download the ABVersion_MD5.Bin file from the Server space.
	3. Compare the MD5 checksums in the Persistent and Server spaces. If they are not equal, proceed to step 4; otherwise, go to step 9 to exit the download process.
	4. Download the ABVersion.Bin version information file from the Server space.
	5. Load the ABVersion.Bin version information file from the Persistent space.
	6. Compare the version information files in the Server and Persistent spaces, recording the resource packages that need to be updated in a List. (Conditions for updating resource packages: a. The version number of a single resource package on the Server is greater than that of the same package in the Persistent space. b. The resource package exists only on the Server.)
	7. Iterate through the list of resource packages that need to be updated, downloading each package from the server to the Persistent space, and update the Persistent space's version information file ABVersion.Bin after downloading each package.
	8. After the entire download process is complete, save the Server's version MD5 checksum to the Persistent space; if the download process is terminated, do not save the version MD5 checksum.
	9. Finally, compare the version files in the Persistent space and the StreamingAssets space to generate the version information data object ABLoaderVersion for resource loading. (The resource package path with the larger version number in the two spaces will be used as the final resource package.)
	10. Complete the update download process.

### Generation of Incremental Update Packages in the Server Space
* Each time resources are packaged, incremental information about the resource packaging will be saved in the History folder of the resource package.
* The packaging tool interface provides a Build function for incremental resource packages, allowing the selection of BuildPackageType as HotfixPackage to extract all incremental resource packages starting from a specific version.

	![AssetbundleHistory](https://github.com/winddyhe/knight/blob/master/Doc/res/images/assetbundle_histroy.png)

## Resource Loading
* The recommended method for resource loading in the framework is LZ4 + Assetbundle.LoadFromFileAsync. This loading scheme is currently the most optimal for AssetBundle loading, maximizing the savings in loading time and memory allocation.
* All version information for resource packages is stored in the ABLoaderVersion object, which is generated through the update process.
* The framework uses coroutines to handle the asynchronous loading of resource packages, using recursive calls to load the dependencies of resource packages.
* Resource loading management in the framework employs a combination of caching Assetbundle objects, reference counting, and Unload(true) to clearly unload specific resources.
* A unified interface for resource loading and unloading at the lower level:
  ```C#
  IAssetLoader Interface
  public AssetLoaderRequest<T> LoadAssetAsync<T>(string rAssetPath, string rAssetName, bool bIsSimulate) where T : Object;
  public AssetLoaderRequest<T> LoadAllAssetAsync<T>(string rAssetPath, bool bIsSimulate) where T : Object;
  public AssetLoaderRequest<T> LoadSceneAsync<T>(string rAssetPath, string rAssetName, LoadSceneMode rSceneMode, bool bIsSimulate) where T : Object;
  public AssetLoaderRequest<T> LoadAllSceneAsync<T>(string rAssetPath, bool bIsSimulate) where T : Object;
  public void Unload<T>(AssetLoaderRequest<T> rRequest) where T : Object;
  ```
* It provides the ability to simulate resource package loading in the Editor using the UnityEditor.AssetDatabase.GetAssetPathsFromAssetBundleAndAssetName and UnityEditor.AssetDatabase.LoadMainAssetAtPath APIs. This means that when resources change in the Editor, there is no need to rebuild the resource package to obtain the correct results.
* By setting the file Assets/Game.Editor/Assetbundle/ABSimulateConfig.asset, you can select it and check IsDevelopMode, IsHotfixABMode, and choose different types of resource simulation in SimulateType.

	![Assetbundle Simulation Mode](https://github.com/winddyhe/knight/blob/master/Doc/res/images/img_2.png)